快速排序具体的流程算法如下：
针对一组数据，首先需要选取其中一个值作为支点，最好选择数组最中间的数（数组长度除以2）
接下来从左边拿0位置拿第一个数与支点5对比，如果4<5,那么指针的位置就偏移到1，然后2<5,一次类推
如果6>5的时候，此时左边的指针就停止移动
然后从右边的指针开始移动，也是如此，只是右边是取的大于的值，比如9>5 ，往前移位，3<5，此时也停止移动，然后交换指针对应的数值
 
________________________________________
第一步:选择支点 
 
 
第二步: 指针在前后开始偏移
 
 
第三步：如果4<5，继续移动左边的指针往下
 
 
第四步：如果2<5，往下，6>5停止
 
 
第五步：9>5，往前，3<5停止
 
 
第六步：交换指针指向的值
 
 
第七步：继续如上的操作，直到支点
 
 
第八部：如果指针到了支点，就停止
 
 function swap(items, firstIndex, secondIndex){
		    var temp = items[firstIndex];
		    items[firstIndex] = items[secondIndex];
		    items[secondIndex] = temp;
}
function partition(items, left, right) {
		    var pivot = items[Math.floor((right + left) / 2)],
		        i = left,
		        j = right;
		    while (i <= j) {
		        while (items[i] < pivot) {
		            i++;
		        }
		        while (items[j] > pivot) {
		            j--;
		        }
		        if (i <= j) {
		            swap(items, i, j);
		            i++;
		            j--;
		        }
		    }
		    return i;
}
这个函数接受三个参数： items ，这是值进行排序的数组， left ，这是左指针，right ，这是右指针。 支点的值是通过将所确定的left和right的值，然后除以2。 因为这个值可能是一个浮点数，有必要进行一些舍入。
整个算法是循环只是一个循环。 外环确定何时所有的数组范围的项目已经被处理。 左，右指针的两个内部循环控制运动。当两个内部循环的完成，则该指针进行比较，以确定是否交换是必要的。 在交换之后，两个指针被移动，使外循环继续，在合适的地方。 该函数返回的左指针的值，因为这是用于确定从哪里开始隔间的下一次。 
快速排序算法基本上通过划分整个数组的工作原理，然后递归地分割阵列的左侧和右侧的部分，直到整个阵列被排序。
在前面的例子中，数组变[4, 2, 3, 5, 6, 9]一个分区，并返回索引后为4（左指针的最后一个席位），开始递归左右2个分割部分
如下面的图所示
第一步：找到指针遍历的位置,确定支点
 
 
第二步：从左右指针位置开始,对比4<3，停止
 
 
第三步：因为5>3,移动右边的指针,因为3==3,停止
 
 
第四步：交换指针指向的值
 
 
第五步：依次如上处理
 
 
第六步：因为2<3,移动左边指针，因为4>3，停止
因为左边的指针超过了右边的指针，停止
 
该过程之后，该阵列变成[3, 2, 4, 5, 6, 9]和返回的索引是1，继续这样，直到所有的阵列左侧的排序。 然后相同的处理接着在右侧的阵列。 基本对数的快速排序，然后变得非常简单：
function quickSort(items, left, right) {
    var index;
    if (items.length > 1) {
        index = partition(items, left, right);
        if (left < index - 1) {
            quickSort(items, left, index - 1);
        }
        if (index < right) {
            quickSort(items, index, right);
        }

    }
    return items;
}
